// 카카오배 양궁 대회가 열렸습니다. 라이언은 저번 카카오배 양궁 대회 우승자이고 이번 대회에도 
// 결승전까지 올라왔습니다. 결승전 상대는 어피치입니다. 카카오배 양궁 대회 운영위원회는 한 선
// 수의 연속 우승보다는 다양한 선수들이 양궁 대회에서 우승하기를 바랍니다. 따라서 양궁 대회 운
// 영위원회는 결승전 규칙을 전 대회 우승자인 라이언에게 불리하게 정했습니다.
// • 어피치가 화살 n발을 다 쏜 후에 라이언이 화살 n발을 쏩니다.
// 양궁 과녁판은 흔히 보는 원형의 형태입니다. 가운데부터 10, 9, 8, ..., 1, 0점으로 계산합니다. k
// 점(k는 1~10사이의 자연수)을 어피치가 a발을 맞혔고, 라이언이 b발을 맞히면 더 많은 화살을 k
// 점에 맞힌 선수가 k점을 가져갑니다. 
// 단 a와 b가 같으면(두 선수가 동일한 횟수로 과녁을 맞히면) 어피치가 k점을 가져갑니다. 예를 들
// 어 어피치가 10점을 2발 맞혔고, 라이언도 10점을 2발 맞히면 어피치가 10점을 가져갑니다. 여기
// 서 20점이 아닌 10점을 가져간다는 점에 주의하세요. k점을 여러 발 맞혀도 k점만 가져갑니다. 또
// 한 a = b = 0이면 그 누구도 k점을 가져가지 않습니다. 다른 예도 볼까요? 어피치가 10점을 0발, 
// 라이언이 10점을 2발 맞히면 라이언이 10점을 가져갑니다. 최종 점수를 계산하여 점수가 더 높은 
// 선수를 우승자로 결정합니다. 만약 최종 점수가 같다면 어피치가 우승자입니다.
// 현재 상황은 어피치가 화살 n발을 다 쏜 후이고, 라이언이 화살을 쏠 차례입니다. 라이언은 어피치
// 를 가장 큰 점수 차이로 이기기 위해서 n발의 화살을 어떤 과녁 점수에 맞혀야 하는지 고민하고 있
// 습니다. 
// 화살의 개수를 담은 자연수 n, 어피치가 맞힌 과녁 점수의 개수를 10점부터 0점까지 순서대로 담
// 은 정수 배열 info가 매개변수로 주어집니다. 이때 라이언이 가장 큰 점수 차이로 우승하기 위
// 해 n발의 화살을 어디에 맞혀야 하는지를 10점부터 0점까지 순서대로 정수 배열에 담아 반환할 

// solution( ) 함수를 구현하세요. 만약 라이언이 우승할 수 없다면 -1를 반환하세요.
// 제약 조건
// • 1 ≤ n ≤ 10
// • info의 길이 = 11
// - 0 ≤ info의 원소 ≤ n
// - info의 원소 총합 = n
// - info의 i번째 원소는 과녁의 10 - i점을 맞힌 화살 개수(i는 0~10 사이의 정수)
// • 라이언이 우승할 방법이 있는 경우 반환할 정수 배열의 길이는 11
// - 0 ≤ 반환할 정수 배열의 원소 ≤ n
// - 반환할 정수 배열의 원소 총합 = n(n발을 다 쏴야 함)
// - 반환할 정수 배열의 i번째 원소는 과녁의 10 - i점을 맞힌 화살 개수(i는 0~10 사이의 정수)
// - 라이언이 가장 큰 점수 차이로 우승할 수 있는 방법이 많다면 가장 낮은 점수를 더 많이 맞
// 힌 경우를 반환
// ■ 가장 낮은 점수를 맞힌 개수가 같으면 그다음으로 낮은 점수를 더 많이 맞힌 경우를 반환
// ■ 예를 들어 [2, 3, 1, 0, 0, 0, 0, 1, 3, 0, 0]과 [2, 1, 0, 2, 0, 0, 0, 2, 3, 0, 0]을 비교하면 
// [2, 1, 0, 2, 0, 0, 0, 2, 3, 0, 0]을 반환
// ■ [0, 0, 2, 3, 4, 1, 0, 0, 0, 0, 0]과 [9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]을 비교하면 
// [9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]을 반환
// • 라이언이 우승할 방법이 없으면 반환할 배열의 길이는 1
// - 라이언이 어떻게 화살을 쏘던 라이언 점수가 어피치 점수보다 낮거나 같으면 [-1]을 반환
// 입출력의 예
// n info result
// 5 [2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0] [0, 2, 2, 0, 1, 0, 0, 0, 0, 0, 0]
// 1 [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] [-1]
// 9 [0, 0, 1, 2, 0, 1, 1, 1, 1, 1, 1] [1, 1, 2, 0, 1, 2, 2, 0, 0, 0, 0]

// 문제가 꽤 복잡하므로 입출력 예의 분석이 매우 중요합니다. 첫 번째 입출력 예를 봅시다. 입출력 
// 예를 표로 정리하면 다음과 같습니다. 이렇게 하면 어피치의 최종 점수는 15점, 라이언의 최종 점
// 수는 19점입니다. 4점 차이로 라이언이 우승합니다.
// 과녁 점수 어피치가 맞힌 화살 개수 라이언이 맞힌 화살 개수 결과
// 10 2 3 라이언이 10점 획득
// 9 1 2 라이언이 9점 획득
// 8 1 0 어피치가 8점 획득
// 7 1 0 어피치가 7점 획득
// 6 0 0 -
// ... ... ... -
// 1 0 0 -
// 0 0 0 -

// 하지만 라이언이 아래와 같이 화살을 맞힐 경우 더 큰 점수 차로 우승할 수 있습니다. 어피치의 최
// 종 점수는 17점, 라이언의 최종 점수는 23점입니다. 6점 차이로 라이언이 우승합니다. 따라서 
// [0, 2, 2, 0, 1, 0, 0, 0, 0, 0, 0]을 반환해야 합니다.
// 과녁 점수 
// 어피치가 맞힌 화살 개수 라이언이 맞힌 화살 개수 결과
// 10 2 0 어피치가 10점 획득
// 9 1 2 라이언이 9점 획득
// 8 1 2 라이언이 8점 획득
// 7 1 0 어피치가 7점 획득
// 6 0 1 라이언이 6점 획득
// 5 0 0 -
// ... ... ... -
// 1 0 0 -
// 0 0 0 -
// 두 번째 입출력 예는 간단합니다. 두 사람 모두 1발만 쏠 수 있는데 어피치가 10점을 맞혔으므로 
// 라이언은 어떻게 해도 이길 수 없습니다. [-1]을 반환합니다.

// 세 번째 입출력 예는 라이언이 [1, 1, 2, 3, 0, 2, 0, 0, 0, 0, 0]으로 맞히면 어피치의 최종 점수는 
// 10점, 라이언의 최종 점수는 39점이고, 라이언이 [1, 1, 2, 0, 1, 2, 2, 0, 0, 0, 0]으로 맞히면 어피
// 치의 최종 점수는 13점, 라이언의 최종 점수는 42점으로 점수 차는 모두 29점으로 같습니다. 두 
// 번째 경우가 가장 낮은 점수인 4점을 더 많이 맞혔으므로 [1, 1, 2, 0, 1, 2, 2, 0, 0, 0, 0]을 반환
// 해야 합니다.

// 프로토타입
// vector<int> solution(int n, vector<int> info)

#include <vector>
#include <iostream>

using namespace std;

vector<int> answer;
vector<int> ryan(11, 0);
int highScore = 3;
int total_arrow = 3;
int maxScore = -1;
int tab = -1;


int calcScoreDiff(const vector<int> &apeach)
{
    int scoreApeach = 0;
    int scoreLion = 0;
    
    for (int i = 0; i < total_arrow + 1; ++i)
    {
        if (apeach[i] == 0 && ryan[i] == 0)
        {
            continue;
        }
 
        // 어피치점수가 높거나 같으면 어피치가 점수 먹음
        if (apeach[i] >= ryan[i])
        {
            scoreApeach += highScore - i;
        }
        else
        {
            // 아니면 라이언이 먹음
            scoreLion += highScore - i;
        }
    }

    return scoreLion - scoreApeach;
}
void indent()
{
    for(int i = 0; i < tab; i++)
    {
        cout << "\t";
    }
}
void dfs(const vector<int> apeach, int score, int arrow)
{
    tab++;
    // indent();
    // cout << "score: " << score << " arrow: " << arrow << " apeach[score]:" << apeach[score] << endl;
    indent();
    for (int i = 0 ; i < 11; i++) 
    {
        cout << ryan[i] << " ";
    }
    cout << endl;
    
    if (score == -1 || arrow == 0)
    {
        // 남은화살 빵점에 다 넣음
        // score 는 언제 -1 될까.
        // 마지막에 실행되는건가. 점수가 -1일경우 arrow 가 0이아닐수가있는건가
        ryan[10] = arrow; 
        int scoreDiff = calcScoreDiff(apeach);
        
        // 현재 구한 점수 차가 기존 최대 점수차보다 더 크고 라이언의 점수가 더 높으면 갱신
        if (scoreDiff > 0 && maxScore < scoreDiff) 
        {
            maxScore = scoreDiff;
            answer = ryan;
        }
        // 그래놓고. 0을 또 넣네 왜...남은걸 넣고선 왜...남은게 있긴하냐
        ryan[10] = 0;
        tab--;
        return;
    }

    // 아직 어피치가 쏠 화살이 남았을 경우??
    // 남은 화살이 어피치가 쏜 화살보다 많으면...
    if (arrow > apeach[score]) {
        ryan[score] = apeach[score] + 1; // 라이언이 어피치보다 한개 더 쏘도록 조정
        int remainArrow = arrow - apeach[score] - 1;
        dfs(apeach, score - 1, remainArrow); // 다음 점수 체크
        ryan[score] = 0; // 문제가 안풀려서 다시 원복한건가.
        indent();
        cout << "ryan's score reset to zero" << endl;
    }


    // 어피치가 화살을 사용하지 않는 경우?? 
    dfs(apeach, score - 1, arrow);
    tab--;
}


vector<int> solution(int n, vector<int> info)
{
    dfs(info, total_arrow, n);

    if (maxScore == -1)
    {
        answer.push_back(-1);
    }
    return answer;
}

void main()
{
    // 5 [2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0] [0, 2, 2, 0, 1, 0, 0, 0, 0, 0, 0]
    // int n = 5;
                    //  10 9  8  7  6  5  4  3  2  1  0
    // vector<int> info = {2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0};

    int n = total_arrow;
    vector<int> info = {1, 2, 0, 0};

    vector<int> result = solution(n, info);

    for(auto item : result)
    {
        cout << item << " ";
    }
    cout << endl;
}